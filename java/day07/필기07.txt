[필기07]  
2-8. 메서드의 리턴값
    - 메서드가 연산 결과를 자신이 호출된 위치에 반환하는 것을 "리턴"
    또는 "반환"이라고 하며, 반환되는 값을 "리턴값"이라고 한다.
    - 메서드 안에서 값을 리턴하기 위해서는 "return" 이라는 키워드가 사용된다.
    - 값을 리턴하는 메서드는 선언시 "void" 키워드 대신, 리턴하는 값의 변수형이 명시된다.
    - 리턴값이 없다면 선언시 "void"를 입력한다.

	public static 리턴형 메서드이름( 변수형 변수이름, 변수형 변수이름, ... ) {
		.. 수행할 연산식 ...
		return 리턴값;
	}

    - 리턴값보다 리턴형의 범위가 더 넓다면 암묵적 형변환된 값이 반환된다.  ex) float 메서드에서 return 5; 하면 5.0이 반환됨

  2-9. 두 개의 함수를 연립하여 사용하기

	...
	메서드도 위와 같이 연립이 가능하다.

  2-10. 메서드 간의 상호 호출
    - java의 메서드도 서로 호출하는 것이 가능하다. 호출된 메서드가 값을 리턴하는 경우,
    리턴값을 다른 연산에 사용할 수 있다.
    - 상호 호출된 메서드들은 위치에 상관없이 호출 가능하다.
    - 예를 들어, 코드 맨아래에 있는 메서드를 그보다 위에 위치한 메서드에서도 호출 가능하다.


------------------------------------------------------------------------------------------------------------------------------------------------
1. 클래스
  1-1. 객체(Object)
    - 프로그래밍에서의 객체는 프로그램에서 구현하고 싶은 기능을 묶기 위한 단위.

  1-2. 객체를 구성하는 단위
    - 객체를 이루는 것은 데이터와 기능이다.
    - 데이터는 변수로 표현되고, 기능은 메서드(함수)로 표현된다.
    - 객체 안에 포함된 변수를 "멤버변수" 또는 "프로퍼티"라고 한다.
   
  1-3. 클래스와 객체의 관계
    - 객체를 생성하기 위해서는 설계도가 필요하다.
    - 객체의 설계도 역할을 하는 프로그램 소스가 클래스(class)이다.
    - 공장에서 하나의 설계도를 사용하여 여러 개의 제품을 생산할 수 있는 것처럼
    하나의 클래스를 통해 동일한 구조를 갖는 객체를 여러 개 생성할 수 있다.
    - 바퀴, 문 등은 멤버변수의 형태로 표현되며, 전진, 후진 등은 메서드의 형태로 표현된다.
    - ex) 자동차(바퀴,문,창문/전진기능,후진기능) 설계도를 기반으로
            -> 승용차(4,4,4/최대120) 버스(4,2,12/최대100) 트럭(4,2,2/최대110) 여러가지 자동차를 만들 수 있다.
    - ex) 1개의 붕어빵틀을 기반으로 여러가지 맛의 붕어빵을 만들 수 있다.

  1-4. 자동차 클래스의 예
    - 동일한 설계로 만들어진 자동차라 하더라도 각각의 자동차를 구성하는 부품은 그 형태만 같을 뿐,
    실제로는 각각 존재하게 된다.
    - 클래스를 작성하면서 그 안에 생성되는 멤버변수들은 여러개의 객체 간 서로 동일한 이름으로 존재하지만,
    실제로는 서로 다른 값이다.

  1-5. 클래스의 기본 작성 방법
	class 클래스이름 {
		멤버변수;
		void 메서드이름() {
		}
	}

    - "class"라는 예약어와 클래스이름을 명시하고 {...} 블록을 구성한다.
    - 클래스이름은 대문자로 시작하게 작성한다.
    - 멤버변수는 여러 개 존재할 수 있다. 이때, 값을 선언과 동시에 할당할 수도 있고, 객체를 통해 간접적으로 할당할 수도 있다.
    - 메서드는 여러 개 존재할 수 있다.
    - 클래스 안의 멤버변수와 메서드들을 특성에 따라 그룹화하는 기법이 클래스를 작성하는 것이라고 할 수 있다.

  1-6. 개체의 선언 및 할당 방법
	클래스이름 객체이름;			// 객체의 선언
	객체 이름 = new 클래스이름(); 		//객체의 할당
	클래스 이름 객체이름 = new 클래스이름();	//객체의 할당+선언

  1-7. 객체의 사용
    - 객체 안에 포함된 변수와 메서드는 점(.)으로 연결하여 접근한다.
	-> 객체 안에 포함된 변수의 값을 다른 변수에 복사하는 경우
		변수 = 객체이름.멤버변수;

	-> 객체 안에 포함된 변수의 값에 다른 값을 대입하는 경우
		객체이름.멤버변수 = 새값;

	-> 객체 안에 포함된 메서드를 호출하는 경우
		객체이름.메서드이름(값1, 값2, ... , 값n);

  1-8. 클래스를 정의하면서 멤버변수에 값을 대입하는 경우
    - Main01.java에서의 객체는 생성됨과 동시에 name변수와 age변수가 할당된 값을 포함하게 된다.
    - 이와 같은 경우, 같은 클래스로 객체를 여러개 생성한다면 모든 객체가 동일한 값을 갖게 된다.
		std	name = "자바학생"
			age = 19
	Student
		std2	name = "자바학생"
			age = 19

    - 같은 클래스로부터 생성된 객체라 할지라도 서로 다른 값을 대입하면 서로 독립적인 형태로 존재한다.

  1-9. 클래스를 정의하면서 값이 대입되지 않은 멤버변수의 경우
    - 클래스란 객체를 위한 틀을 제공하는 것이기 때문에, 클래스 작성과정에서 멤버변수에 대입된 값은
    객체를 통해 멤버변수를 지정하기 전까지 사용된 "기본값(default)"으로서의 의미이다.
    ex) 자동차 클래스를 생성할 때 바퀴는 기본적으로 4개이므로 기본값으로서 4를 대입해놓을 수 있고, 색상은 모두 다르기 때문에
         기본값을 따로 대입하지 않아도 된다.
    - 객체를 통하여 새로운 값이 대입되면 클래스 작성시 멤버변수에 대입되었던 값은 의미를 잃어버리게 된다.
    - 때문에 일반적으로 클래스 작성시 멤버변수에 값을 지정하지 "않는다".
    - 값이 할당되지 않은 멤버변수에는 디폴트로 "null" 또는 "0"이 저장된다. (오류 없음)


  1-10. 메서드를 포함하는 클래스
    - 메서드란 프로그램에서 하나의 동작 단위를 의미한다.
    - 두 개 이상의 메서드가 서로 동일한 대상을 위해서 존재할 경우, 이 메서드들을 클래스에 포함시켜 그룹화할 수 있다.
    - 클래스에 멤버변수와 메서드가 공존할 경우, 멤버변수는 모든 메서드가 공유하는 전역변수로 존재하게 된다.
    - 변수의 종류
	-> 멤버변수(=전역변수)
	: 클래스 안에서 선언된 변수. 클래스 블록 범위 안에서 모두 유효하다.
	-> 지역변수
	: 메서드 안에서 선언된 변수. 메서드의 블록을 빠져나가 사용되지 못한다.
	그러므로 타 메서드는 지역변수를 인식하지 못한다. 이 규칙은
	조건문, 반복문과 같은 {...}블록을 형성하는 모든 경우에 해당한다.

** 참고 - 전역변수와 지역변수
- 지역변수와 전역변수는 선언되는 메모리 영역이 다르다.
- 전역변수는 Heap영역에 저장된다. 지역변수는 Stack영역에 저장되어, 자동 초기화(선언하자마자 default값이 존재하게 되는 것)되지 않는다.
(heap : 프로그래머가 원하는 방식대로 쓸 수 있는 저장공간. 긴 생명주기를 가진 데이터들이 저장된다.)
(stack : 일시적으로만 사용하고 삭제할 데이터의 저장공간.)

  1-11. 메서드만을 포함하는 클래스
    - 객체 안에 멤버변수, 즉 데이터가 존재하지 않는다.
    - 객체 안에 포함된 메서드를 호출하여 결과를 만들기 위한 목적이므로, 굳이 여러 개의 객체를 생성하지 않는다.
    - 계산기능을 갖는 클래스의 예
	class Calc{
		int sum( int x, int y ){
			return x + y;
		}
	}

	// 두 개의 값을 위하여 객체를 각각 생성하는 경우 (비효율적)
	Calc c1 = new Calc();
	int a = c1.sum( 100, 200 );
	System.out.println( a );

	Calc c2 = new Calc();
	int b = c2.sum( 200, 300 );
	System.out.println( b );

    - 파라미터에 의해 결과를 반환하는 경우, 서로 다른 값을 위하여 객체를 여러개 생성할 필요가 없다.
    - 자체적으로 데이터를 갖지 않고 외부적 요인(파라미터)에 의해서 결과가 생성되므로, 하나의 객체를 계속
    재사용하는 것이 더 바람직하다. 메모리를 효율적으로 사용하기 때문이다.
	
	// 두 개의 값을 위하여 1개의 객체만을 생성하는 경우 (효율적)
	Calc c1 = new Calc();
	int a = c1.sum(100,200);
	System.out.println(a);
	
	// 처음 생성한 c1객체를 재사용한다.
	int b = c1.sum(100,200);	
	System.out.println(b);	

2. This
  2-1. 자기 자신을 의미하는 키워드
    - 클래스 안에서 this를 사용하여 "자기 자신"을 표현한다.

  2-2. this를 사용하여 지역변수와 전역변수 구분하기

	class Student {
		String name;
		public void setName(){
			String name;		// 변수충돌 없음! 이유는 아래.
			name = "자바학생";
		}
	}
    - 전역변수와 지역변수가 동일한 이름으로 공존할 경우, "유효성 범위가 작은" 변수가 우선적으로 인식된다.
    - 전역변수의 범위는 클래스 전체 > 지역변수의 범위는 블록 내부
    - 따라서 위 "자바학생"은 지역변수 name에 할당된다.

    - 전역변수를 인식하는 방법으로는 this.xxx 를 사용하는 방법이 있다.
	class Student {
		String name;
		public void setName(){
			String name;		// 변수충돌 없음.
			name = "자바학생";		// 우선 인식되는 지역변수에 할당된다.
			this.name = "JSP학생";	// this에 의해 전역변수에 할당된다.
		}
	}

    - this를 사용해서 파라미터와 멤버변수 구하기
	-> 메서드 파라미터도 해당 메서드 안에서만 유효한 지역변수의 일종이다.
	-> 파라미터를 사용하여 멤버변수의 값을 간접적으로 설정할 경우,
	이름은 동일하게 지정하고 this 키워드를 사용하여 멤버변수와 파라미터를 구별하여 작성하는게
	java언어의 일반적인 처리 방식이다.
	
	class Student {
		String name;
		public void setName(String name) {		// 이 name은 setName메서드 내에서만 사용 가능한 지역변수
			// 입력받은 지역변수 name의 값을 전역변수 name에 할당하고자 한다.
			// 다음과 같이 작성하면 된다.
			this.name = name;
		}
	}

	ex) Student x = new Student();
	// x.name = "자바학생" 이라 쓰지 않고도 메서드를 사용하여 멤버변수 name에 값을 할당할 수 있게 된다.
	x.setName("자바학생");

    - "모든" 멤버변수 앞에 this 키워드를 사용하여 직관적으로 표시하는 것이 소스코드의 가독성을 위해 바람직하다.
    - 즉, 같은 이름의 지역변수가 없어도 보편적으로 this를 붙여준다.
